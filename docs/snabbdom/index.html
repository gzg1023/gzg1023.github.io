<!DOCTYPE html>
<html lang='zh' ><meta charset="utf-8">
<meta name="viewport" content="width=device-width">


<title>snabbdom中文文档 | 沽默清尘</title>
<link rel="stylesheet" href="/css/eureka.min.css">
<script defer src="/js/eureka.min.js"></script>

<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link rel="preload"
  href="https://fonts.googleapis.com/css2?family=Lora:wght@400;600;700&family=Noto+Serif+SC:wght@400;600;700&display=swap"
  as="style" onload="this.onload=null;this.rel='stylesheet'">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.1.0/build/styles/solarized-light.min.css"
   media="print"
  onload="this.media='all';this.onload=null" crossorigin>
<script defer src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.1.0/build/highlight.min.js"
   crossorigin></script>
<script defer src="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.14.0/js/all.min.js"
   integrity="sha256-uNYoXefWRqv&#43;PsIF/OflNmwtKM4lStn9yrz2gVl6ymo="  crossorigin></script>


<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"
   integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3&#43;Aro6EYUG4&#43;cU&#43;KJWu/X"  media="print"
  onload="this.media='all';this.onload=null" crossorigin>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js" 
  integrity="sha384-g7c&#43;Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI&#43;sEnkvrMWph2EDg4"  crossorigin></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js"
   integrity="sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC&#43;Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa"  crossorigin></script>
<script>
  document.addEventListener("DOMContentLoaded", function () {
    renderMathInElement(document.body, {
      delimiters: [
        { left: "$$", right: "$$", display: true },
        { left: "$", right: "$", display: false },
        { left: "\\(", right: "\\)", display: false },
        { left: "\\[", right: "\\]", display: true }
      ],
    });
  });
</script>


<link rel="icon" type="image/png" sizes="32x32" href="/images/favicon_hu4dd3a7947c4cdf24f3f1440430310555_390_32x32_fill_box_center_2.png">
<link rel="apple-touch-icon" sizes="180x180" href="/images/favicon_hu4dd3a7947c4cdf24f3f1440430310555_390_180x180_fill_box_center_2.png">

<meta name="description"
  content="snabbdom库文档的翻译">
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [{
      "@type": "ListItem",
      "position": 1 ,
      "name":"Docs",
      "item":"/docs/"},{
      "@type": "ListItem",
      "position": 2 ,
      "name":"snabbdom中文文档",
      "item":"/docs/snabbdom/"}]
}
</script>



<script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Article",
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "/docs/snabbdom/"
    },
    "headline": "snabbdom中文文档 | 沽默清尘","wordCount":  1439 ,
    "publisher": {
        "@type": "Person",
        "name": "gzg1023",
        "logo": {
            "@type": "ImageObject",
            "url": "https://ae02.alicdn.com/kf/Hc12b72efe97141c4b21a7d0bc4b889dao.png"
        }
        },
    "description": "snabbdom库文档的翻译"
}
</script><meta property="og:title" content="snabbdom中文文档 | 沽默清尘" />
<meta property="og:type" content="website" />


<meta property="og:image" content="/images/favicon.png">


<meta property="og:url" content="/docs/snabbdom/" />



<meta property="og:description" content="snabbdom库文档的翻译" />



<meta property="og:locale" content="zh" />




<meta property="og:site_name" content="沽默清尘" />






<meta property="og:updated_time" content="2021-02-06T00:00:00&#43;00:00" />



<meta property="article:section" content="docs" />


<link rel="alternate" type="application/rss+xml" href="/docs/snabbdom/index.xml" title="沽默清尘" />

<body class="flex flex-col min-h-screen">
  <header class="fixed flex items-center w-full min-h-16 pl-scrollbar z-50 bg-secondary-bg shadow-sm">
    <div class="w-full max-w-screen-xl mx-auto"><script>
    let storageColorScheme = localStorage.getItem("lightDarkMode")
    if (((storageColorScheme == 'Auto' || storageColorScheme == null) && window.matchMedia("(prefers-color-scheme: dark)").matches) || storageColorScheme == "Dark") {
        document.getElementsByTagName('html')[0].classList.add('dark')
    }
</script>
<nav class="flex items-center justify-between flex-wrap px-4 py-4 md:py-0">
    <a href="/" class="mr-6 text-primary-text text-xl font-bold">沽默清尘</a>
    <button id="navbar-btn" class="md:hidden flex items-center px-3 py-2" aria-label="Open Navbar">
        <i class="fas fa-bars"></i>
    </button>

    <div id="target"
        class="hidden block md:flex md:flex-grow md:justify-between md:items-center w-full md:w-auto text-primary-text z-20">
        <div class="md:flex md:h-16 text-sm md:flex-grow pb-4 md:pb-0 border-b md:border-b-0">
            <a href="/posts/" class="block mt-4 md:inline-block md:mt-0 md:h-(16-4px) md:leading-(16-4px) box-border md:border-t-2 md:border-b-2  border-transparent  mr-4">Posts</a>
            <a href="/tags/" class="block mt-4 md:inline-block md:mt-0 md:h-(16-4px) md:leading-(16-4px) box-border md:border-t-2 md:border-b-2  border-transparent  mr-4">Tags</a>
            <a href="/docs/" class="block mt-4 md:inline-block md:mt-0 md:h-(16-4px) md:leading-(16-4px) box-border md:border-t-2 md:border-b-2  selected-menu-item  mr-4">Docs</a>
        </div>

        <div class="flex">
            <div class="relative pt-4 md:pt-0">
                <div class="cursor-pointer hover:text-eureka" id="lightDarkMode">
                    <i class="fas fa-adjust"></i>
                </div>
                <div class="fixed hidden inset-0 opacity-0 h-full w-full cursor-default z-30" id="is-open">
                </div>
                <div class="absolute flex flex-col left-0 md:left-auto right-auto md:right-0 hidden bg-secondary-bg w-48 rounded py-2 border border-tertiary-bg cursor-pointer z-40"
                    id='lightDarkOptions'>
                    <span class="px-4 py-1 hover:text-eureka">Light</span>
                    <span class="px-4 py-1 hover:text-eureka">Dark</span>
                    <span class="px-4 py-1 hover:text-eureka">Auto</span>
                </div>
            </div>
        </div>
    </div>

    <div class="fixed hidden inset-0 opacity-0 h-full w-full cursor-default z-0" id="is-open-mobile">
    </div>

</nav>
<script>
    let element = document.getElementById('lightDarkMode')
    if (storageColorScheme == null || storageColorScheme == 'Auto') {
        document.addEventListener('DOMContentLoaded', () => {
            switchMode('Auto')
        })
    } else if (storageColorScheme == "Light") {
        element.firstElementChild.classList.remove('fa-adjust')
        element.firstElementChild.setAttribute("data-icon", 'sun')
        element.firstElementChild.classList.add('fa-sun')
    } else if (storageColorScheme == "Dark") {
        element.firstElementChild.classList.remove('fa-adjust')
        element.firstElementChild.setAttribute("data-icon", 'moon')
        element.firstElementChild.classList.add('fa-moon')
    }
    
    document.addEventListener('DOMContentLoaded', () => {
        getcolorscheme();
        switchBurger();
    });
</script></div>
  </header>
  <main class="flex-grow pt-16">
    <div class="pl-scrollbar">
      <div class="w-full max-w-screen-xl lg:px-4 xl:px-8 mx-auto">


<div class="lg:pt-12">
    <div class="flex flex-col md:flex-row bg-secondary-bg rounded">
        <div class="md:w-1/4 lg:w-1/5 border-r">
            <div class="sticky top-16 pt-6">
                





<div id="sidebar-title" class="md:hidden mx-4 px-2 pt-4 pb-2 md:border-b text-tertiary-text md:text-primary-text">
    <span class="font-semibold">目录</span>
    <i class="fas fa-caret-right ml-1"></i>
</div>

<div id="sidebar-toc"
    class="hidden md:block overflow-y-auto mx-6 md:mx-0 pr-6 pt-2 md:max-h-doc-sidebar bg-primary-bg md:bg-transparent">
    <div class="flex flex-wrap ml-4 -mr-2 p-2 bg-secondary-bg md:bg-primary-bg rounded">
        <a class="text-eureka hover:text-eureka"
            href="/docs/snabbdom/">snabbdom中文文档</a>
        
        
        


    </div>
    
<ul class="pl-6">
    
</ul>

</div>



            </div>

        </div>
        <div class="w-full md:w-3/4 lg:w-4/5 pb-8 pt-2 md:pt-8">
            <div class="w-full lg:w-3/4 pl-6 ml-0 mr-auto">
                <h1 class="font-bold text-3xl text-primary-text">snabbdom中文文档</h1>
                <div class="flex flex-wrap flex-row items-center mt-2 text-tertiary-text">
    <div class="mr-6 my-2">
        <i class="fas fa-calendar mr-1"></i>
        <span>2021-02-06</span>
    </div>
    
    
    

    
</div>
            </div>
            <div class="flex">
                <div class="w-full lg:w-3/4 px-6">
                    
                    
                    <div class="content">
                        <p>snabbdom库的翻译,主要是翻译README文件，介绍了一些api的使用。</p>
<img alt="Snabbdom" src="https://raw.githubusercontent.com/snabbdom/snabbdom/master/readme-title.svg" width="356px">
<p>原文地址：<a href="https://github.com/snabbdom/snabbdom/blob/master/README.md">https://github.com/snabbdom/snabbdom/blob/master/README.md</a></p>
<p>一个注重简单性、模块化、强大功能和性能的虚拟DOM库。</p>
<hr>
<h2 id="介绍">介绍</h2>
<p>虚拟DOM很厉害。它允许我们将应用程序的视图作为其状态的函数来表达。但是现有的解决方案太过臃肿，太过缓慢，缺乏功能，API偏向于OOP缺乏需要的功能。</p>
<p>Snabbdom由一个极其简单、性能优异、可扩展的内核组成，代码 ≈ 200行。它提供了一个模块化的架构，具有丰富的功能，可以通过自定义模块进行扩展。为了保持核心的简单性，所有非必要的功能都委托给模块。</p>
<p>你可以把Snabbdom塑造成任何你想要的东西! 选择或自定义你想要的功能。你也可以直接使用默认的扩展。</p>
<p>Snabbdom具有以下特点：</p>
<h2 id="特点">特点</h2>
<ul>
<li>
<p>核心特点</p>
<ul>
<li>约200行代码&ndash;你可以很容易地读完整个核心，并完全理解它的工作原理。</li>
<li>可通过模块进行扩展。</li>
<li>丰富的Hook函数，既可用于每个vnode，也可用于全局模块。
嵌入diff和patch的任何部分。</li>
<li>优秀的性能。Snabbdom是最快的虚拟DOM库之一。</li>
<li>patch函数，其函数签名相当于reduce/scan函数。允许更容易地与FRP库集成。</li>
</ul>
</li>
<li>
<p>模块的特点</p>
<ul>
<li><code>h</code>函数，用于轻松创建虚拟DOM节点。</li>
<li><a href="#svg">SVG与<code>h</code>一起工作</a>。</li>
<li>用于制作复杂的CSS动画的功能。</li>
<li>强大的事件监听器功能。</li>
<li><a href="#thunks">Thunks</a>可进一步diff和patch过程。</li>
</ul>
</li>
<li>
<p>第三方功能</p>
<ul>
<li>JSX支持，感谢<a href="https://github.com/Swizz/snabbdom-pragma">snabbdom-pragma</a>。</li>
<li>服务器端 HTML 输出由 <a href="https://github.com/acstll/snabbdom-to-html">snabbdom-to-html</a> 提供。</li>
<li>使用 <a href="https://github.com/krainboltgreene/snabbdom-helpers">snabbdom-helpers</a> 创建紧凑的虚拟 DOM。</li>
<li>使用 <a href="https://github.com/jamen/snabby">snabby</a> 支持模板字符串。</li>
<li>使用<a href="https://github.com/jvanbruegge/snabbdom-looks-like">snabbdom-looks-like</a>进行虚拟DOM断言。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="内容表格">内容表格</h2>
<ul>
<li><a href="#%E6%A0%B8%E5%BF%83%E6%96%87%E6%A1%A3">核心文档</a>
<ul>
<li><a href="#init"><code>init</code></a></li>
<li><a href="#patch"><code>patch</code></a>
<ul>
<li><a href="#unmounting">Unmounting</a></li>
</ul>
</li>
<li><a href="#snabbdomh"><code>snabbdom/h</code></a></li>
<li><a href="#snabbdomtovnode"><code>snabbdom/tovnode</code></a></li>
<li><a href="#hooks">Hooks</a>
<ul>
<li><a href="#overview">Overview</a></li>
<li><a href="#usage">Usage</a></li>
<li><a href="#initHook">The <code>init</code> hook</a></li>
<li><a href="#insertHook">The <code>insert</code> hook</a></li>
<li><a href="#removeHook">The <code>remove</code> hook</a></li>
<li><a href="#destroyHook">The <code>destroy</code> hook</a></li>
</ul>
</li>
<li><a href="#%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%9D%97">Creating modules</a></li>
</ul>
</li>
<li><a href="#modules%E6%96%87%E6%A1%A3">Modules documentation</a>
<ul>
<li><a href="#class%E6%A8%A1%E5%9D%97">The class module</a></li>
<li><a href="#props%E6%A8%A1%E5%9D%97">The props module</a></li>
<li><a href="#attributes%E6%A8%A1%E5%9D%97">The attributes module</a></li>
<li><a href="#dataset%E6%A8%A1%E5%9D%97">The dataset module</a></li>
<li><a href="#style%E6%A8%A1%E5%9D%97">The style module</a>
<ul>
<li>[Custom properties (CSS variables)](#CSS variables)</li>
<li><a href="#delayed-properties">Delayed properties</a></li>
<li><a href="#%E8%AE%BE%E7%BD%AE-remove-%E7%9A%84%E5%B1%9E%E6%80%A7">Set properties on <code>remove</code></a></li>
<li><a href="#%E8%AE%BE%E7%BD%AE-destroy-%E7%9A%84%E5%B1%9E%E6%80%A7">Set properties on <code>destroy</code></a></li>
</ul>
</li>
<li><a href="#%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E6%A8%A1%E5%9D%97">事件监听模块</a></li>
</ul>
</li>
<li><a href="#svg">SVG</a>
<ul>
<li><a href="#svg%E5%85%83%E7%B4%A0%E4%B8%AD%E7%9A%84%E7%B1%BB">svg元素中的类</a></li>
</ul>
</li>
<li><a href="#thunks">Thunks</a></li>
<li><a href="#virtual-node">Virtual Node</a>
<ul>
<li><a href="#sel--string">sel : String</a></li>
<li><a href="#data--object">data : Object</a></li>
<li><a href="#children--arrayvnode">children : Array<vnode></a></li>
<li><a href="#text--string">text : string</a></li>
<li><a href="#elm--element">elm : Element</a></li>
<li><a href="#key--string--number">key : string | number</a></li>
</ul>
</li>
<li><a href="#%E6%9E%84%E5%BB%BA%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F">构建应用程序</a></li>
</ul>
<h2 id="核心文档">核心文档</h2>
<p>Snabbdom的核心只提供最基本的功能。它的设计是尽可能的简单，同时仍然是快速和可扩展的。</p>
<h3 id="init"><code>init</code></h3>
<p>核心只公开一个函数 &ldquo;init&rdquo;。这个<code>init</code>函数
取一个模块列表，并返回一个使用该函数的<code>patch</code>函数。
指定的模块集。</p>
<pre><code class="language-mjs">import { classModule } from 'snabbdom/modules/class'
import { styleModule } from 'snabbdom/modules/style'

var patch = init([classModule, styleModule])
</code></pre>
<h3 id="patch"><code>patch</code></h3>
<p><code>init</code>返回的<code>patch</code>函数有两个参数。第一个是代表当前视图的DOM元素或vnode。第二个是代表新的、更新的视图的vnode。</p>
<p>如果传递一个有父节点的DOM元素，&ldquo;newVnode &ldquo;将变成一个DOM节点，传递的元素将被创建的DOM节点替换。如果传递了一个旧的vnode，Snabbdom将有效地修改它以匹配新vnode中的描述。</p>
<p>任何旧的vnode必须是之前调用<code>patch</code>的结果。这是必要的，因为Snabbdom在vnode中存储信息。这使得它可以实现一个更简单和更高性能的架构。这也避免了创建一个新的旧的vnode树。</p>
<pre><code class="language-mjs">patch(oldVnode, newVnode)
</code></pre>
<h4 id="unmounting">Unmounting</h4>
<p>虽然没有专门用于从挂载点元素中移除VNode树的API，但有一种方法几乎可以实现这一点，即提供一个注释VNode作为<code>patch</code>的第二个参数，例如：</p>
<pre><code class="language-mjs">patch(oldVnode, h('!', { hooks: { post: () =&gt; { /* patch complete */ } } }))
</code></pre>
<p>当然，那么在挂载点还是有一个单一的注释节点。</p>
<h3 id="snabbdomh"><code>snabbdom/h</code></h3>
<p>建议你使用<code>snabbdom/h</code>来创建vnodes。<code>h</code>接受一个作为字符串的标签/选择器、一个可选的数据对象和一个可选的字符串或子代数组。</p>
<pre><code class="language-mjs">import { h } from 'snabbdom/h'

var vnode = h('div', { style: { color: '#000' } }, [
  h('h1', 'Headline'),
  h('p', 'A paragraph'),
])
</code></pre>
<h3 id="snabbdomtovnode"><code>snabbdom/tovnode</code></h3>
<p>将一个DOM节点转换为一个虚拟节点。特别适合于在已有的、服务器端生成的内容上打patch。</p>
<pre><code class="language-mjs">import { init } from 'snabbdom/init'
import { classModule } from 'snabbdom/modules/class'
import { propsModule } from 'snabbdom/modules/props'
import { styleModule } from 'snabbdom/modules/style'
import { eventListenersModule } from 'snabbdom/modules/eventlisteners'
import { h } from 'snabbdom/h' // helper function for creating vnodes
import { toVNode } from 'snabbdom/tovnode'

var patch = init([ // Init patch function with chosen modules
  classModule, // makes it easy to toggle classes
  propsModule, // for setting properties on DOM elements
  styleModule, // handles styling on elements with support for animations
  eventListenersModule, // attaches event listeners
])

var newVNode = h('div', { style: { color: '#000' } }, [
  h('h1', 'Headline'),
  h('p', 'A paragraph'),
])

patch(toVNode(document.querySelector('.container')), newVNode)
</code></pre>
<h3 id="hooks">Hooks</h3>
<p>hooks是一种钩入DOM节点生命周期的方式。Snabbdom提供了丰富的hook选择。Hook既可以被模块用来扩展Snabbdom，也可以在正常的代码中用于在虚拟节点的生命周期中执行任意代码。</p>
<h4 id="概述">概述</h4>
<table>
<thead>
<tr>
<th>名称</th>
<th>触发时机</th>
<th>回调参数</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>pre</code></td>
<td>patch函数开始时候</td>
<td>none</td>
</tr>
<tr>
<td><code>init</code></td>
<td>增加了一个vnode</td>
<td><code>vnode</code></td>
</tr>
<tr>
<td><code>create</code></td>
<td>基于vnode的DOM元素已经被创建。</td>
<td><code>emptyVnode, vnode</code></td>
</tr>
<tr>
<td><code>insert</code></td>
<td>元素已被插入到DOM中</td>
<td><code>vnode</code></td>
</tr>
<tr>
<td><code>prepatch</code></td>
<td>元素即将被修补</td>
<td><code>oldVnode, vnode</code></td>
</tr>
<tr>
<td><code>update</code></td>
<td>元素正在更新</td>
<td><code>oldVnode, vnode</code></td>
</tr>
<tr>
<td><code>postpatch</code></td>
<td>元素已被修补</td>
<td><code>oldVnode, vnode</code></td>
</tr>
<tr>
<td><code>destroy</code></td>
<td>被直接或间接删除的元素</td>
<td><code>vnode</code></td>
</tr>
<tr>
<td><code>remove</code></td>
<td>元素被直接从DOM中删除</td>
<td><code>vnode, removeCallback</code></td>
</tr>
<tr>
<td><code>post</code></td>
<td>patch函数已完成</td>
<td>none</td>
</tr>
</tbody>
</table>
<p>钩子清单: <code>pre</code>, <code>create</code>,<code>update</code>, <code>destroy</code>, <code>remove</code>, <code>post</code>.</p>
<p>下列Hook可在单个项目的 &ldquo;Hook &ldquo;属性中使用。
elements: <code>init</code>, <code>create</code>, <code>insert</code>, <code>prepatch</code>, <code>update</code>,
<code>postpatch</code>, <code>destroy</code>, <code>remove</code>.</p>
<h4 id="使用方法">使用方法</h4>
<p>要使用Hook，将它们作为一个对象传递到数据对象参数的<code>hook</code>字段。</p>
<pre><code class="language-mjs">h('div.row', {
  key: movie.rank,
  hook: {
    insert: (vnode) =&gt; { movie.elmHeight = vnode.elm.offsetHeight }
  }
})
</code></pre>
<h4 id="inithook"><code>init</code>Hook</h4>
<p>这个Hook在patch过程中，当发现一个新的虚拟节点时被调用。这个Hook在Snabbdom以任何方式处理节点之前被调用。也就是说，在它基于vnode创建一个DOM节点之前。</p>
<h4 id="insert-hook"><code>insert</code> Hook</h4>
<p>一旦vnode的DOM元素被调用，这个Hook就会被调用。插入到文档中，剩下的patch周期就完成了。这意味着你可以进行DOM测量（比如使用<a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect">getBoundingClientRect</a>在这个Hook中安全地使用，因为知道任何元素都不会被改变后，可能会影响插入元素的位置。</p>
<h4 id="remove-hook"><code>remove</code> Hook</h4>
<p>允许您挂钩删除元素。 一旦要从DOM中删除vnode，就会调用该Hook。 处理函数同时接收vnode和回调。 您可以使用回调控制和延迟删除。 挂钩完成其业务后，应立即调用该回调，并且仅在所有`remove&rsquo;挂钩均已调用其回调之后，才删除该元素。</p>
<p>仅当要从其父元素中删除元素时才触发该Hook，而如果它是要删除的元素的子元素则不会触发。 为此，请参见<code>destroy</code>Hook。</p>
<h4 id="destroy-hook"><code>destroy</code> Hook</h4>
<p>当从DOM中删除其DOM元素或从DOM中删除其父元素时，将在虚拟节点上调用此挂钩。</p>
<p>要查看此Hook和<code>remove</code>Hook之间的区别，如下。</p>
<pre><code class="language-mjs">var vnode1 = h('div', [h('div', [h('span', 'Hello')])])
var vnode2 = h('div', [])
patch(container, vnode1)
patch(vnode1, vnode2)
</code></pre>
<p>这里，&ldquo;destroy &ldquo;对内部的 &ldquo;div &ldquo;元素和它所包含的 &ldquo;span &ldquo;元素都会被触发。另一方面，&ldquo;remove &ldquo;只在 &ldquo;div &ldquo;元素上触发，因为它是唯一一个从其父元素中分离出来的元素。</p>
<p>例如，你可以使用<code>remove</code>在元素被移除时触发动画，并使用<code>destroy</code>Hook为被移除元素的子元素的消失附加动画。</p>
<h3 id="创建模块">创建模块</h3>
<p>模块的工作原理是为<a href="#hooks">hooks</a>注册全局监听器。一个模块就是一个将Hook名称映射到函数的字典。</p>
<pre><code class="language-mjs">var myModule = {
  create: function (oldVnode, vnode) {
    // invoked whenever a new virtual node is created
  },
  update: function (oldVnode, vnode) {
    // invoked whenever a virtual node is updated
  }
}
</code></pre>
<h2 id="modules-文档">Modules 文档</h2>
<p>描述了核心模块。所有模块都是可选的。</p>
<h3 id="class-模块">class 模块</h3>
<p>类模块提供了一个简单的方法来动态切换元素上的类。它期望在<code>class</code>数据属性中找到一个对象。该对象应该将类名映射到布尔值，以指示该类是否应该留在或离开vnode上。</p>
<pre><code class="language-mjs">h('a', { class: { active: true, selected: false } }, 'Toggle')
</code></pre>
<h3 id="props-模块">props 模块</h3>
<p>允许你设置DOM元素的属性。</p>
<pre><code class="language-mjs">h('a', { props: { href: '/foo' } }, 'Go to Foo')
</code></pre>
<p>属性只能设置。不能删除。尽管浏览器允许添加和删除自定义属性，但该模块不会尝试删除。
这是有道理的，因为原生DOM属性不能被删除。如果你使用自定义属性来存储值或引用DOM上的对象，那么请考虑使用下面的模块。
<a href="https://developer.mozilla.org/enUS/docs/Learn/HTML/Howto/Use_data_attributes">数据/*属性</a> 而不是。也许通过<a href="#the-dataset-module">数据集模块</a>。</p>
<h3 id="attributes-模块">attributes 模块</h3>
<p>和 props 模块一样，但在DOM元素上设置属性而不是属性。</p>
<pre><code class="language-mjs">h('a', { attrs: { href: '/foo' } }, 'Go to Foo')
</code></pre>
<p>使用<code>setAttribute</code>添加和更新属性。如果是一个以前添加/设置过的属性，现在已经不存在了。中的属性，它将从DOM元素的属性中被移除。列表中使用<code>removeAttribute</code>。</p>
<p>如果是布尔属性(如 <code>disabled</code>、<code>hidden</code>、<code>selected</code>&hellip;)，其意义不取决于属性值。(<code>true </code>或 <code>false</code>)，而是取决于是否存在/不存在以下情况：
属性本身在DOM元素中。这些属性被处理为模块的不同：如果一个布尔属性被设置为一个
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean">falsy value</a>
(<code>0</code>, <code>-0</code>, <code>null</code>, <code>false</code>,<code>NaN</code>, <code>undefined</code>, 或空字符串)(<code>&quot;&quot;</code>))，则该属性将从属性列表中删除DOM元素。</p>
<p>通过www.DeepL.com/Translator（免费版）翻译</p>
<h3 id="dataset-模块">dataset 模块</h3>
<p>允许你在DOM元素上设置自定义数据属性（<code>data-*</code>）。然后可以通过<a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/dataset">HTMLElement.dataset</a>属性访问这些属性。</p>
<pre><code class="language-mjs">h('button', { dataset: { action: 'reset' } }, 'Reset')
</code></pre>
<h3 id="style-模块">style 模块</h3>
<p>样式模块是为了让你的HTML看起来光滑和流畅的动画。在
它的核心是允许你对元素设置CSS属性。</p>
<pre><code class="language-mjs">h('span', {
  style: { border: '1px solid #bada55', color: '#c0ffee', fontWeight: 'bold' }
}, 'Say my name, and every colour illuminates')
</code></pre>
<p>需要注意的是，如果样式模块的样式属性是作为属性从样式对象中移除。要删除一个样式。你应该把它设置为空字符串。</p>
<pre><code class="language-mjs">h('div', {
  style: { position: shouldFollow ? 'fixed' : '' }
}, 'I, I follow, I follow you')
</code></pre>
<h4 id="css-variables">CSS variables</h4>
<p>支持CSS自定义属性，它们必须以<code>--</code>为前缀。</p>
<pre><code class="language-mjs">h('div', {
  style: { '--warnColor': 'yellow' }
}, 'Warning')
</code></pre>
<h4 id="delayed-properties">delayed-properties</h4>
<p>您可以指定被延迟的属性。每当这些属性发生变化时，该变化直到下一帧之后才会被应用。</p>
<pre><code class="language-mjs">h('span', {
  style: { opacity: '0', transition: 'opacity 1s', delayed: { opacity: '1' } }
}, 'Imma fade right in!')
</code></pre>
<p>这使得它很容易声明性地对元素的进入进行动画。</p>
<p>不支持 <code>transition-property</code>的<code>all</code>值。</p>
<h4 id="设置-remove-的属性">设置 &ldquo;remove &ldquo;的属性</h4>
<p>在 &ldquo;remove &ldquo;属性中设置的样式将在该元素被删除后生效。 即将被从DOM中移除。应用的样式应该是用CSS过渡动画。只有当所有的样式都完成后动画将元素从DOM中移除。</p>
<pre><code class="language-mjs">h('span', {
  style: {
    opacity: '1',
    transition: 'opacity 1s',
    remove: { opacity: '0' }
  }
}, 'It\'s better to fade out than to burn away')
</code></pre>
<p>这使得它很容易声明性地对元素的移除进行动画。</p>
<p>不支持 <code>transition-property</code>的<code>all</code>值。</p>
<h4 id="设置-销毁-的属性">设置 &ldquo;销毁 &ldquo;的属性</h4>
<pre><code class="language-mjs">h('span', {
  style: {
    opacity: '1',
    transition: 'opacity 1s',
    destroy: { opacity: '0' }
  }
}, 'It\'s better to fade out than to burn away')
</code></pre>
<p>不支持 <code>transition-property</code>的<code>all</code>值。</p>
<h3 id="事件监听模块">事件监听模块</h3>
<p>The event listeners module gives powerful capabilities for attaching
event listeners.</p>
<p>你可以通过在<code>on</code>提供一个与事件名称相对应的属性的对象，将一个函数附加到一个vnode上的事件上。
你想监听的事件。该函数将在事件发生时被调用，并将传递属于它的事件对象。
事件监听器模块提供了强大的附加事件监听器的功能。</p>
<pre><code class="language-mjs">function clickHandler (ev) {
  console.log('got clicked')
}
h('div', { on: { click: clickHandler } })
</code></pre>
<p>然而，很多时候，你对事件对象并不真正感兴趣。本身。通常情况下，你有一些与元素相关联的数据，这些数据就是 触发一个事件，而你想让这些数据传递下去。</p>
<p>考虑一个有三个按钮的计数器应用程序，其中一个按钮用来递增 计数器增加1，一个增加2，一个增加 你并不关心到底是哪个按钮使计数器增加3。被按下。相反，你感兴趣的是什么数字是相关的。与点击的按钮。事件监听模块允许人们 通过在命名的事件属性处提供一个数组来表达。列表中的 数组中的第一个元素应该是一个将被调用的函数。与第二个元素中的值，一旦事件发生。</p>
<pre><code class="language-mjs">function clickHandler (number) {
  console.log('button ' + number + ' was clicked!')
}
h('div', [
  h('a', { on: { click: ()=&gt;{clickHandler(1)} } }),
  h('a', { on: { click: ()=&gt;{clickHandler(2)} } }),
  h('a', { on: { click: ()=&gt;{clickHandler(3)} } }),
])
</code></pre>
<p>每个处理程序的调用不仅包括给定的参数，还包括当前事件和附加到参数列表中的vnode。它还支持通过指定一个处理程序数组来使用每个事件的多个监听器</p>
<pre><code class="language-mjs">stopPropagation = function (ev) {
  ev.stopPropagation()
}
sendValue = function (func, ev, vnode) {
  func(vnode.elm.value)
}

h('a', { on: { click: [[sendValue, console.log], stopPropagation] } })
</code></pre>
<p>Snabbdom允许在渲染之间交换事件处理程序。这发生在不实际接触DOM上的事件处理程序的情况下。</p>
<p>但是，请注意，<strong>在vnodes</strong>之间共享事件处理程序时应该小心，因为该模块使用了避免将事件处理程序重新绑定到DOM的技术。而且一般来说，vnodes之间共享数据并不能保证有效，因为模块是允许突变给定数据的）。</p>
<p>尤其是，你<strong>不应该</strong>做这样的事情。</p>
<pre><code class="language-mjs">
var sharedHandler = {
  change: function (e) { console.log('you chose: ' + e.target.value) }
}
h('div', [
  h('input', {
    props: { type: 'radio', name: 'test', value: '0' },
    on: sharedHandler
  }),
  h('input', {
    props: { type: 'radio', name: 'test', value: '1' },
    on: sharedHandler
  }),
  h('input', {
    props: { type: 'radio', name: 'test', value: '2' },
    on: sharedHandler
  })
])
</code></pre>
<p>对于许多这样的情况，你可以使用基于数组的处理程序来代替（如上所述）。
或者，简单地确保每个节点都被传递了唯一的<code>on</code>值。</p>
<pre><code class="language-mjs">// Works
var sharedHandler = function (e) {
  console.log('you chose: ' + e.target.value)
}
h('div', [
  h('input', {
    props: { type: 'radio', name: 'test', value: '0' },
    on: { change: sharedHandler }
  }),
  h('input', {
    props: { type: 'radio', name: 'test', value: '1' },
    on: { change: sharedHandler }
  }),
  h('input', {
    props: { type: 'radio', name: 'test', value: '2' },
    on: { change: sharedHandler }
  })
])
</code></pre>
<h2 id="svg">SVG</h2>
<p>当使用<code>h</code>函数创建虚拟的SVG时，SVG就能正常工作节点。SVG元素会自动创建相应的命名空间。</p>
<pre><code class="language-mjs">var vnode = h('div', [
  h('svg', { attrs: { width: 100, height: 100 } }, [
    h('circle', { attrs: { cx: 50, cy: 50, r: 40, stroke: 'green', 'stroke-width': 4, fill: 'yellow' } })
  ])
])
</code></pre>
<h3 id="svg元素中的类">SVG元素中的类</h3>
<p>某些浏览器（如IE &lt;=11）<a href="http://caniuse.com/#feat=classlist">不支持SVG元素中的<code>classList</code>属性</a>。
因为_class_模块内部使用<code>classList</code>，在这种情况下，除非你使用<a href="https://www.npmjs.com/package/classlist-polyfill">classList polyfill</a>，否则它将无法工作。如果你不想使用polyfill，你可以使用_attributes_模块的<code>class</code>属性）。</p>
<h2 id="thunks">Thunks</h2>
<p><code>thunk</code>函数需要一个选择器、一个用于识别thunk的键、一个返回vnode的函数和一个可变数量的状态参数。如果调用，渲染函数将接收状态参数。</p>
<p><code>thunk(selector, key, renderFn, [stateArguments])</code></p>
<p>只有当 &ldquo;renderFn &ldquo;改变或&rdquo;[stateArguments]&ldquo;数组长度或其元素改变时，才会调用 &ldquo;renderFn&rdquo;。</p>
<p><code>key</code>是可选的。当<code>selector</code>被选中时，它应该被提供。
在thunks兄弟姐妹中并不唯一。这确保了thunk是
差异化时总是正确匹配。</p>
<p>Thunks是一种优化策略，当一个人是处理不可更改的数据。</p>
<p>考虑一个简单的函数，用于基于一个数字创建一个虚拟节点。</p>
<pre><code class="language-mjs">function numberView (n) {
  return h('div', 'Number is: ' + n)
}
</code></pre>
<p>视图只取决于<code>n</code>。这意味着，如果<code>n</code>不变：
然后创建虚拟DOM节点，并对旧的
vnode是浪费的。为了避免开销，我们可以使用 &ldquo;thunk &ldquo;辅助工具。
职能。</p>
<pre><code class="language-mjs">function render (state) {
  return thunk('num', numberView, [state.number])
}
</code></pre>
<p>而不是实际调用 &ldquo;numberView &ldquo;函数，这将只是 在虚拟树中放置一个虚拟的vnode。当Snabbdom对这个 的值进行比较，它将比较 <code>n</code>. 如果<code>n</code>没有变化，它将简单地重新使用旧的vnode。这 完全避免了重新创建数字视图和差异过程。
这里的视图功能只是一个例子。在实践中，thunks只是 如果您要渲染一个复杂的视图，而这个视图需要 显著的计算时间来生成。</p>
<h2 id="virtual-node">Virtual Node</h2>
<p><strong>Properties</strong></p>
<ul>
<li><a href="#sel--string">sel</a></li>
<li><a href="#data--object">data</a></li>
<li><a href="#children--array">children</a></li>
<li><a href="#text--string">text</a></li>
<li><a href="#elm--element">elm</a></li>
<li><a href="#key--string--number">key</a></li>
</ul>
<h3 id="sel--string">sel : String</h3>
<p>The <code>.sel</code> property of a virtual node is the CSS selector passed to
<a href="#snabbdomh"><code>h()</code></a> during creation. For example: <code>h('div#container', {}, [...])</code> will create a a virtual node which has <code>div#container</code> as
its <code>.sel</code> property.</p>
<h3 id="data--object">data : Object</h3>
<p>The <code>.data</code> property of a virtual node is the place to add information
for <a href="#modules-documentation">modules</a> to access and manipulate the
real DOM element when it is created; Add styles, CSS classes,
attributes, etc.</p>
<p>The data object is the (optional) second parameter to <a href="#snabbdomh"><code>h()</code></a></p>
<p>For example <code>h('div', {props: {className: 'container'}}, [...])</code> will produce a virtual node with</p>
<pre><code class="language-mjs">({
  props: {
    className: 'container'
  }
})
</code></pre>
<p>as its <code>.data</code> object.</p>
<h3 id="children--arrayvnode">children : Array<vnode></h3>
<p>The <code>.children</code> property of a virtual node is the third (optional)
parameter to <a href="#snabbdomh"><code>h()</code></a> during creation. <code>.children</code> is
simply an Array of virtual nodes that should be added as children of
the parent DOM node upon creation.</p>
<p>For example <code>h('div', {}, [ h('h1', {}, 'Hello, World') ])</code> will
create a virtual node with</p>
<pre><code class="language-mjs">[
  {
    sel: 'h1',
    data: {},
    children: undefined,
    text: 'Hello, World',
    elm: Element,
    key: undefined,
  }
]
</code></pre>
<p>as its <code>.children</code> property.</p>
<h3 id="text--string">text : string</h3>
<p>当创建的虚拟节点只有一个拥有文本的子节点，只需要使用<code>document.createTextNode()</code>就可以创建<code>.text</code>属性。</p>
<p>For example: <code>h('h1', {}, 'Hello')</code> will create a virtual node with
<code>Hello</code> as its <code>.text</code> property.</p>
<h3 id="elm--element">elm : Element</h3>
<p>虚拟节点的<code>.elm</code>属性是指向真实DOM的指针。
由Snabbdom创建的节点。这个属性在做以下事情时非常有用<a href="#hooks">Hook</a>中的计算结果以及<a href="#modules-documentation">模块</a>。</p>
<h3 id="key--string--number">key : string | number</h3>
<p><code>.key</code>属性是在你的 <a href="#data--object"><code>.data</code></a>对象。<code>.key</code>属性用于保存。指向以前存在的DOM节点的指针，以避免重新创建它们。如果它是不必要的。这对于像 list 重新排序。键必须是字符串或数字，以便于进行 的内部存储为键/值对，因此可以进行正确的查找。对象，其中<code>.key</code>是键，值是 创建<a href="#elm--%E5%85%83%E7%B4%A0"><code>.elm</code></a>属性。</p>
<p>如果提供，<code>.key</code>属性必须在同级元素中是唯一的。</p>
<p>例如：<code>h('div', {key: 1}, [])</code>将创建一个虚拟节点。对象，其<code>.key</code>属性的值为<code>1</code>。</p>
<h2 id="构建应用程序">构建应用程序</h2>
<p>Snabbdom是一个的虚拟DOM库。它与
关于如何构建你的应用程序的问题，以下是一些使用Snabbdom构建应用程序的方法。</p>
<p>下面是一些使用Snabbdom构建应用程序的方法。</p>
<ul>
<li><a href="https://github.com/paldepind/functional-frontend-architecture">functional-frontend-architecture</a> –
a repository containing several example applications that
demonstrates an architecture that uses Snabbdom.</li>
<li><a href="https://cycle.js.org/">Cycle.js</a> –
&ldquo;A functional and reactive JavaScript framework for cleaner code&rdquo;
uses Snabbdom</li>
<li><a href="http://vuejs.org/">Vue.js</a> use a fork of snabbdom.</li>
<li><a href="https://github.com/amirouche/scheme-todomvc/">scheme-todomvc</a> build
redux-like architecture on top of snabbdom bindings.</li>
<li><a href="https://github.com/AlexGalays/kaiju">kaiju</a> -
Stateful components and observables on top of snabbdom</li>
<li><a href="https://tweedjs.github.io">Tweed</a> –
An Object Oriented approach to reactive interfaces.</li>
<li><a href="http://cyclow.js.org">Cyclow</a> -
&ldquo;A reactive frontend framework for JavaScript&rdquo;
uses Snabbdom</li>
<li><a href="https://github.com/Reon90/tung">Tung</a> –
A JavaScript library for rendering html. Tung helps to divide html and JavaScript development.</li>
<li><a href="https://github.com/theia-ide/sprotty">sprotty</a> - &ldquo;A web-based diagramming framework&rdquo; uses Snabbdom.</li>
<li><a href="https://github.com/marktext/marktext">Mark Text</a> - &ldquo;Realtime preview Markdown Editor&rdquo; build on Snabbdom.</li>
<li><a href="https://github.com/flintinatux/puddles">puddles</a> -
&ldquo;Tiny vdom app framework. Pure Redux. No boilerplate.&rdquo; - Built with ❤️ on Snabbdom.</li>
<li><a href="https://github.com/jcbrand/backbone.vdomview">Backbone.VDOMView</a> - A <a href="http://backbonejs.org/">Backbone</a> View with VirtualDOM capability via Snabbdom.</li>
<li><a href="https://github.com/lukaszmakuch/rosmaro-snabbdom-starter">Rosmaro Snabbdom starter</a> - Building user interfaces with state machines and Snabbdom.</li>
<li><a href="https://github.com/irony/pureact">Pureact</a> - &ldquo;65 lines implementation of React incl Redux and hooks with only one dependency - Snabbdom&rdquo;</li>
<li><a href="https://github.com/tobymao/snabberb">Snabberb</a> - A minimalistic Ruby framework using <a href="https://github.com/opal/opal">Opal</a> and Snabbdom for building reactive views.</li>
</ul>
                    </div>
                    
                    

                    

                    
                    
                </div>
                
                <div class="hidden lg:block lg:w-1/4">
                    
                    <div class="sticky top-16 z-10 hidden lg:block px-6 py-4  bg-secondary-bg pt-16 -mt-16 ">
    <span class="text-lg font-semibold">本页内容</span>
</div>
<div class="sticky-toc hidden lg:block px-6 pb-6  pt-10 -mt-10 border-l ">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#介绍">介绍</a></li>
    <li><a href="#特点">特点</a></li>
    <li><a href="#内容表格">内容表格</a></li>
    <li><a href="#核心文档">核心文档</a>
      <ul>
        <li><a href="#init"><code>init</code></a></li>
        <li><a href="#patch"><code>patch</code></a>
          <ul>
            <li><a href="#unmounting">Unmounting</a></li>
          </ul>
        </li>
        <li><a href="#snabbdomh"><code>snabbdom/h</code></a></li>
        <li><a href="#snabbdomtovnode"><code>snabbdom/tovnode</code></a></li>
        <li><a href="#hooks">Hooks</a>
          <ul>
            <li><a href="#概述">概述</a></li>
            <li><a href="#使用方法">使用方法</a></li>
            <li><a href="#inithook"><code>init</code>Hook</a></li>
            <li><a href="#insert-hook"><code>insert</code> Hook</a></li>
            <li><a href="#remove-hook"><code>remove</code> Hook</a></li>
            <li><a href="#destroy-hook"><code>destroy</code> Hook</a></li>
          </ul>
        </li>
        <li><a href="#创建模块">创建模块</a></li>
      </ul>
    </li>
    <li><a href="#modules-文档">Modules 文档</a>
      <ul>
        <li><a href="#class-模块">class 模块</a></li>
        <li><a href="#props-模块">props 模块</a></li>
        <li><a href="#attributes-模块">attributes 模块</a></li>
        <li><a href="#dataset-模块">dataset 模块</a></li>
        <li><a href="#style-模块">style 模块</a>
          <ul>
            <li><a href="#css-variables">CSS variables</a></li>
            <li><a href="#delayed-properties">delayed-properties</a></li>
            <li><a href="#设置-remove-的属性">设置 &ldquo;remove &ldquo;的属性</a></li>
            <li><a href="#设置-销毁-的属性">设置 &ldquo;销毁 &ldquo;的属性</a></li>
          </ul>
        </li>
        <li><a href="#事件监听模块">事件监听模块</a></li>
      </ul>
    </li>
    <li><a href="#svg">SVG</a>
      <ul>
        <li><a href="#svg元素中的类">SVG元素中的类</a></li>
      </ul>
    </li>
    <li><a href="#thunks">Thunks</a></li>
    <li><a href="#virtual-node">Virtual Node</a>
      <ul>
        <li><a href="#sel--string">sel : String</a></li>
        <li><a href="#data--object">data : Object</a></li>
        <li><a href="#children--arrayvnode">children : Array<vnode></a></li>
        <li><a href="#text--string">text : string</a></li>
        <li><a href="#elm--element">elm : Element</a></li>
        <li><a href="#key--string--number">key : string | number</a></li>
      </ul>
    </li>
    <li><a href="#构建应用程序">构建应用程序</a></li>
  </ul>
</nav>
</div>
<script>
    window.addEventListener('DOMContentLoaded', () => {
        enableStickyToc();
    });
</script>
                    
                </div>
                
            </div>

        </div>


    </div>
</div>

<script>
    document.addEventListener('DOMContentLoaded', () => {
        hljs.initHighlightingOnLoad();
        changeSidebarHeight();
        switchDocToc();
    })
</script>









      </div>
    </div>
    
  </main>
  <footer class="pl-scrollbar">
    <div class="w-full max-w-screen-xl mx-auto"><div class="text-center p-6 pin-b">
    <p class="text-sm text-tertiary-text">&copy; 2019-2021   gzg1023 &middot;  Powered by the <a href="https://github.com/wangchucheng/hugo-eureka" class="hover:text-eureka">Eureka</a> theme for <a href="https://gohugo.io" class="hover:text-eureka">Hugo</a></p>
</div></div>
  </footer>
</body>

</html>