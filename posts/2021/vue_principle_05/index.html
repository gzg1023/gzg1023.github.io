<!DOCTYPE html>
<html lang='zh' ><meta charset="utf-8">
<meta name="viewport" content="width=device-width">


<title>vue.js(2.x)原理 - Virtual dom及Compile模版编译器原理分析)「05」 | 沽默清尘</title>
<link rel="stylesheet" href="/css/eureka.min.css">
<script defer src="/js/eureka.min.js"></script>

<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link rel="preload"
  href="https://fonts.googleapis.com/css2?family=Lora:wght@400;600;700&family=Noto+Serif+SC:wght@400;600;700&display=swap"
  as="style" onload="this.onload=null;this.rel='stylesheet'">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.1.0/build/styles/solarized-light.min.css"
   media="print"
  onload="this.media='all';this.onload=null" crossorigin>
<script defer src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.1.0/build/highlight.min.js"
   crossorigin></script>
<script defer src="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.14.0/js/all.min.js"
   integrity="sha256-uNYoXefWRqv&#43;PsIF/OflNmwtKM4lStn9yrz2gVl6ymo="  crossorigin></script>


<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"
   integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3&#43;Aro6EYUG4&#43;cU&#43;KJWu/X"  media="print"
  onload="this.media='all';this.onload=null" crossorigin>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js" 
  integrity="sha384-g7c&#43;Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI&#43;sEnkvrMWph2EDg4"  crossorigin></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js"
   integrity="sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC&#43;Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa"  crossorigin></script>
<script>
  document.addEventListener("DOMContentLoaded", function () {
    renderMathInElement(document.body, {
      delimiters: [
        { left: "$$", right: "$$", display: true },
        { left: "$", right: "$", display: false },
        { left: "\\(", right: "\\)", display: false },
        { left: "\\[", right: "\\]", display: true }
      ],
    });
  });
</script>


<link rel="icon" type="image/png" sizes="32x32" href="/images/favicon_hu4dd3a7947c4cdf24f3f1440430310555_390_32x32_fill_box_center_2.png">
<link rel="apple-touch-icon" sizes="180x180" href="/images/favicon_hu4dd3a7947c4cdf24f3f1440430310555_390_180x180_fill_box_center_2.png">

<meta name="description"
  content="
vue2 增加了 v-dom 功能让 vue 大方光彩也可以跨平台。而模版语法是 vue 最重要的特性，本文让我们来看看编写的模版语法是怎么一步步变成浏览器中真实 DOM 元素。
">
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [{
      "@type": "ListItem",
      "position": 1 ,
      "name":"Posts",
      "item":"/posts/"},{
      "@type": "ListItem",
      "position": 2 ,
      "name":"vue.js(2.x)原理 - Virtual dom及Compile模版编译器原理分析)「05」",
      "item":"/posts/2021/vue_principle_05/"}]
}
</script>



<script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Article",
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "/posts/2021/vue_principle_05/"
    },
    "headline": "vue.js(2.x)原理 - Virtual dom及Compile模版编译器原理分析)「05」 | 沽默清尘","datePublished": "2021-07-22T00:00:00+00:00",
    "dateModified": "2021-07-22T00:00:00+00:00",
    "wordCount":  1531 ,
    "publisher": {
        "@type": "Person",
        "name": "gzg1023",
        "logo": {
            "@type": "ImageObject",
            "url": "https://i.loli.net/2021/03/06/kHzcVZrX2uDW6Jg.jpg"
        }
        },
    "description": "\u003cblockquote\u003e\n\u003cp\u003evue2 增加了 v-dom 功能让 vue 大方光彩也可以跨平台。而模版语法是 vue 最重要的特性，本文让我们来看看编写的模版语法是怎么一步步变成浏览器中真实 DOM 元素。\u003c\/p\u003e\n\u003c\/blockquote\u003e"
}
</script><meta property="og:title" content="vue.js(2.x)原理 - Virtual dom及Compile模版编译器原理分析)「05」 | 沽默清尘" />
<meta property="og:type" content="article" />


<meta property="og:image" content="/images/favicon.png">


<meta property="og:url" content="/posts/2021/vue_principle_05/" />




<meta property="og:description" content="
vue2 增加了 v-dom 功能让 vue 大方光彩也可以跨平台。而模版语法是 vue 最重要的特性，本文让我们来看看编写的模版语法是怎么一步步变成浏览器中真实 DOM 元素。
" />




<meta property="og:locale" content="zh" />




<meta property="og:site_name" content="沽默清尘" />






<meta property="article:published_time" content="2021-07-22T00:00:00&#43;00:00" />


<meta property="article:modified_time" content="2021-07-22T00:00:00&#43;00:00" />



<meta property="article:section" content="posts" />


<meta property="article:tag" content="前端" />

<meta property="article:tag" content="vue原理" />

<meta property="article:tag" content="vue源码" />





<meta property="og:see_also" content="/posts/2021/vue_principle_04/" />

<meta property="og:see_also" content="/posts/2021/vue_principle_03/" />

<meta property="og:see_also" content="/posts/2021/vue_principle_02/" />

<meta property="og:see_also" content="/posts/2021/vue_principle_01/" />

<meta property="og:see_also" content="/posts/2021/vue_principle_main/" />

<meta property="og:see_also" content="/posts/2021/snabbdom_source/" />



<body class="flex flex-col min-h-screen">
  <header class="fixed flex items-center w-full min-h-16 pl-scrollbar z-50 bg-secondary-bg shadow-sm">
    <div class="w-full max-w-screen-xl mx-auto"><script>
    let storageColorScheme = localStorage.getItem("lightDarkMode")
    if (((storageColorScheme == 'Auto' || storageColorScheme == null) && window.matchMedia("(prefers-color-scheme: dark)").matches) || storageColorScheme == "Dark") {
        document.getElementsByTagName('html')[0].classList.add('dark')
    }
</script>
<nav class="flex items-center justify-between flex-wrap px-4 py-4 md:py-0">
    <a href="/" class="mr-6 text-primary-text text-xl font-bold">沽默清尘</a>
    <button id="navbar-btn" class="md:hidden flex items-center px-3 py-2" aria-label="Open Navbar">
        <i class="fas fa-bars"></i>
    </button>

    <div id="target"
        class="hidden block md:flex md:flex-grow md:justify-between md:items-center w-full md:w-auto text-primary-text z-20">
        <div class="md:flex md:h-16 text-sm md:flex-grow pb-4 md:pb-0 border-b md:border-b-0">
            <a href="/posts/" class="block mt-4 md:inline-block md:mt-0 md:h-(16-4px) md:leading-(16-4px) box-border md:border-t-2 md:border-b-2  selected-menu-item  mr-4">文章</a>
            <a href="/tags/" class="block mt-4 md:inline-block md:mt-0 md:h-(16-4px) md:leading-(16-4px) box-border md:border-t-2 md:border-b-2  border-transparent  mr-4">标签</a>
            <a href="/docs/" class="block mt-4 md:inline-block md:mt-0 md:h-(16-4px) md:leading-(16-4px) box-border md:border-t-2 md:border-b-2  border-transparent  mr-4">文档</a>
        </div>

        <div class="flex">
            <div class="relative pt-4 md:pt-0">
                <div class="cursor-pointer hover:text-eureka" id="lightDarkMode">
                    <i class="fas fa-adjust"></i>
                </div>
                <div class="fixed hidden inset-0 opacity-0 h-full w-full cursor-default z-30" id="is-open">
                </div>
                <div class="absolute flex flex-col left-0 md:left-auto right-auto md:right-0 hidden bg-secondary-bg w-48 rounded py-2 border border-tertiary-bg cursor-pointer z-40"
                    id='lightDarkOptions'>
                    <span class="px-4 py-1 hover:text-eureka">Light</span>
                    <span class="px-4 py-1 hover:text-eureka">Dark</span>
                    <span class="px-4 py-1 hover:text-eureka">Auto</span>
                </div>
            </div>
        </div>
    </div>

    <div class="fixed hidden inset-0 opacity-0 h-full w-full cursor-default z-0" id="is-open-mobile">
    </div>

</nav>
<script>
    let element = document.getElementById('lightDarkMode')
    if (storageColorScheme == null || storageColorScheme == 'Auto') {
        document.addEventListener('DOMContentLoaded', () => {
            switchMode('Auto')
        })
    } else if (storageColorScheme == "Light") {
        element.firstElementChild.classList.remove('fa-adjust')
        element.firstElementChild.setAttribute("data-icon", 'sun')
        element.firstElementChild.classList.add('fa-sun')
    } else if (storageColorScheme == "Dark") {
        element.firstElementChild.classList.remove('fa-adjust')
        element.firstElementChild.setAttribute("data-icon", 'moon')
        element.firstElementChild.classList.add('fa-moon')
    }
    
    document.addEventListener('DOMContentLoaded', () => {
        getcolorscheme();
        switchBurger();
    });
</script></div>
  </header>
  <main class="flex-grow pt-16">
    <div class="pl-scrollbar">
      <div class="w-full max-w-screen-xl lg:px-4 xl:px-8 mx-auto">


<div class="grid grid-cols-2 lg:grid-cols-8 gap-4 lg:pt-12">
    <div
        class="col-span-2  lg:col-span-6 bg-secondary-bg rounded px-6 py-8">
        <h1 class="font-bold text-3xl text-primary-text">vue.js(2.x)原理 - Virtual dom及Compile模版编译器原理分析)「05」</h1>
        <div class="flex flex-wrap flex-row items-center mt-2 text-tertiary-text">
    <div class="mr-6 my-2">
        <i class="fas fa-calendar mr-1"></i>
        <span>2021-07-22</span>
    </div>
    
    
    
    <div class="mr-6 my-2">
        <i class="fas fa-folder mr-1"></i>
        
        <a href="/categories/%E6%8A%80%E6%9C%AF/" class="hover:text-eureka">技术</a>
        
        
        <span>, </span>
        <a href="/categories/vue%E6%BA%90%E7%A0%81/" class="hover:text-eureka">vue源码</a>
        
        
        <span>, </span>
        <a href="/categories/vue%E5%8E%9F%E7%90%86/" class="hover:text-eureka">vue原理</a>
        
    </div>
    

    
</div>
        
        
        

        <div class="content">
            <blockquote>
<p>vue2 增加了 v-dom 功能让 vue 大方光彩也可以跨平台。而模版语法是 vue 最重要的特性，本文让我们来看看编写的模版语法是怎么一步步变成浏览器中真实 DOM 元素。</p>
</blockquote>
<h2 id="v-dom">v-dom</h2>
<h3 id="是什么">是什么</h3>
<p>在之前写个一片文章<a href="https://gzg.me/posts/2021/snabbdom_source/">https://gzg.me/posts/2021/snabbdom_source</a> 介绍了 v-dom 和 snabbdom 的源码，vue2.x 就是基于改库进行二次封装的。</p>
<h3 id="改进部分">改进部分</h3>
<p>在 vue2 中不是完全照搬 snabbdom，而是基于 vue 的场景进行了一些修改。此部分重点说一下两个部分，判断 key 和 diff 部分。</p>
<h4 id="key-的变化">key 的变化</h4>
<p>在 snabbdom 中 通过 key 和 sel 就判断是否为同一节点，那么在 vue 中，增加了一些判断 在满足 key 相等的同时会判断，tag 名称是否一致，是否为注释节点，是否为异步节点，或者为 input 时候类型是否相同等。</p>
<pre><code class="language-js">const hooks = [&quot;create&quot;, &quot;activate&quot;, &quot;update&quot;, &quot;remove&quot;, &quot;destroy&quot;];
/**
 *
 * @param a 被对比节点
 * @param {*} b  对比节点
 * 对比两个节点是否相同
 * 需要组成的条件：key相同，tag相同，是否都为注释节点，是否同事定义了data，如果是input标签，那么type必须相同
 */
function sameVnode(a, b) {
  return (
    a.key === b.key &amp;&amp;
    ((a.tag === b.tag &amp;&amp;
      a.isComment === b.isComment &amp;&amp;
      isDef(a.data) === isDef(b.data) &amp;&amp;
      sameInputType(a, b)) ||
      (isTrue(a.isAsyncPlaceholder) &amp;&amp;
        a.asyncFactory === b.asyncFactory &amp;&amp;
        isUndef(b.asyncFactory.error)))
  );
}
</code></pre>
<h4 id="patchvnode">patchVnode</h4>
<p>patch 是对比模版变化的函数，可能会用到 diff 也可能直接更新</p>
<p>patchVnode 规则</p>
<ol>
<li>如果新旧 VNode 都是静态的，同时它们的 key 相同（代表同一节点），并且新的 VNode 是 clone 或者是标记了 once（标记 v-once 属性，只渲染一次），那么只需要替换 elm 以及 componentInstance 即可。</li>
<li>新老节点均有 children 子节点，则对子节点进行 diff 操作，调用 updateChildren，这个 updateChildren 也是 diff 的核心。</li>
<li>如果老节点没有子节点而新节点存在子节点，先清空老节点 DOM 的文本内容，然后为当前 DOM 节点加入子节点。</li>
<li>当新节点没有子节点而老节点有子节点的时候，则移除该 DOM 节点的所有子节点。</li>
<li>当新老节点都无子节点的时候，只是文本的替换</li>
</ol>
<pre><code class="language-js">function patchVnode(
  oldVnode,
  vnode,
  insertedVnodeQueue,
  ownerArray,
  index,
  removeOnly
) {
  if (oldVnode === vnode) {
    return;
  }

  if (isDef(vnode.elm) &amp;&amp; isDef(ownerArray)) {
    // clone reused vnode
    vnode = ownerArray[index] = cloneVNode(vnode);
  }

  const elm = (vnode.elm = oldVnode.elm);

  if (isTrue(oldVnode.isAsyncPlaceholder)) {
    if (isDef(vnode.asyncFactory.resolved)) {
      hydrate(oldVnode.elm, vnode, insertedVnodeQueue);
    } else {
      vnode.isAsyncPlaceholder = true;
    }
    return;
  }
  if (
    isTrue(vnode.isStatic) &amp;&amp;
    isTrue(oldVnode.isStatic) &amp;&amp;
    vnode.key === oldVnode.key &amp;&amp;
    (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))
  ) {
    vnode.componentInstance = oldVnode.componentInstance;
    return;
  }

  let i;
  const data = vnode.data;
  if (isDef(data) &amp;&amp; isDef((i = data.hook)) &amp;&amp; isDef((i = i.prepatch))) {
    i(oldVnode, vnode);
  }

  const oldCh = oldVnode.children;
  const ch = vnode.children;
  if (isDef(data) &amp;&amp; isPatchable(vnode)) {
    for (i = 0; i &lt; cbs.update.length; ++i) cbs.update[i](oldVnode, vnode);
    if (isDef((i = data.hook)) &amp;&amp; isDef((i = i.update))) i(oldVnode, vnode);
  }
  if (isUndef(vnode.text)) {
    // 定义了子节点，且不相同，用diff算法对比
    if (isDef(oldCh) &amp;&amp; isDef(ch)) {
      if (oldCh !== ch)
        updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly);
      // 新节点有子元素。旧节点没有
    } else if (isDef(ch)) {
      if (process.env.NODE_ENV !== &quot;production&quot;) {
        // 检查key
        checkDuplicateKeys(ch);
      }
      // 清空旧节点的text属性
      if (isDef(oldVnode.text)) nodeOps.setTextContent(elm, &quot;&quot;);
      // 添加新的Vnode
      addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
      // 如果旧节点的子节点有内容，新的没有。那么直接删除旧节点子元素的内容        } else if (isDef(oldCh)) {
      removeVnodes(oldCh, 0, oldCh.length - 1);
      // 如上。只是判断是否为文本节点
    } else if (isDef(oldVnode.text)) {
      nodeOps.setTextContent(elm, &quot;&quot;);
    }
    // 如果文本节点不同，替换节点内容
  } else if (oldVnode.text !== vnode.text) {
    nodeOps.setTextContent(elm, vnode.text);
  }
  if (isDef(data)) {
    if (isDef((i = data.hook)) &amp;&amp; isDef((i = i.postpatch))) i(oldVnode, vnode);
  }
}
</code></pre>
<h4 id="核心-diff">核心 diff</h4>
<ul>
<li>
<p>首先，在新老两个 VNode 节点的左右头尾两侧都有一个变量标记，在遍历过程中这几个变量都会向中间靠拢。当 oldStartIdx &gt; oldEndIdx 或者 newStartIdx &gt; newEndIdx 时结束循环。
索引与 VNode 节点的对应关系： oldStartIdx =&gt; oldStartVnode oldEndIdx =&gt; oldEndVnode newStartIdx =&gt; newStartVnode newEndIdx =&gt; newEndVnode</p>
</li>
<li>
<p>在遍历中，如果存在 key，并且满足 sameVnode，会将该 DOM 节点进行复用，否则则会创建一个新的 DOM 节点。</p>
</li>
<li>
<p>oldStartVnode、oldEndVnode 与 newStartVnode、newEndVnode 两两比较一共有 2*2=4 种比较方法。
当新老 VNode 节点的 start 或者 end 满足 sameVnode 时，也就是 sameVnode(oldStartVnode, newStartVnode)或者 sameVnode(oldEndVnode, newEndVnode)，直接将该 VNode 节点进行 patchVnode 即可。</p>
</li>
<li>
<p>如果 oldStartVnode 与 newEndVnode 满足 sameVnode，即 sameVnode(oldStartVnode, newEndVnode)。</p>
</li>
</ul>
<p>这时候说明 oldStartVnode 已经跑到了 oldEndVnode 后面去了，进行 patchVnode 的同时还需要将真实 DOM 节点移动到 oldEndVnode 的后面。</p>
<ul>
<li>
<p>如果 oldEndVnode 与 newStartVnode 满足 sameVnode，即 sameVnode(oldEndVnode, newStartVnode)。</p>
</li>
<li>
<p>这说明 oldEndVnode 跑到了 oldStartVnode 的前面，进行 patchVnode 的同时真实的 DOM 节点移动到了 oldStartVnode 的前面。
如果以上情况均不符合，则通过 createKeyToOldIdx 会得到一个 oldKeyToIdx，里面存放了一个 key 为旧的 VNode，value 为对应 index 序列的哈希表。</p>
</li>
<li>
<p>从这个哈希表中可以找到是否有与 newStartVnode 一致 key 的旧的 VNode 节点，如果同时满足 sameVnode，
patchVnode 的同时会将这个真实 DOM（elmToMove）移动到 oldStartVnode 对应的真实 DOM 的前面。</p>
</li>
<li>
<p>有可能 newStartVnode 在旧的 VNode 节点找不到一致的 key，或者是即便 key 相同却不是 sameVnode，这个时候会调用 createElm 创建一个新的 DOM 节点。</p>
</li>
</ul>
<pre><code class="language-js">function updateChildren(
  parentElm,
  oldCh,
  newCh,
  insertedVnodeQueue,
  removeOnly
) {
  let oldStartIdx = 0;
  let newStartIdx = 0;
  let oldEndIdx = oldCh.length - 1;
  let oldStartVnode = oldCh[0];
  let oldEndVnode = oldCh[oldEndIdx];
  let newEndIdx = newCh.length - 1;
  let newStartVnode = newCh[0];
  let newEndVnode = newCh[newEndIdx];
  let oldKeyToIdx, idxInOld, vnodeToMove, refElm;
  const canMove = !removeOnly;

  if (process.env.NODE_ENV !== &quot;production&quot;) {
    checkDuplicateKeys(newCh);
  }

  while (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) {
    if (isUndef(oldStartVnode)) {
      oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left
    } else if (isUndef(oldEndVnode)) {
      oldEndVnode = oldCh[--oldEndIdx];
    } else if (sameVnode(oldStartVnode, newStartVnode)) {
      patchVnode(
        oldStartVnode,
        newStartVnode,
        insertedVnodeQueue,
        newCh,
        newStartIdx
      );
      oldStartVnode = oldCh[++oldStartIdx];
      newStartVnode = newCh[++newStartIdx];
    } else if (sameVnode(oldEndVnode, newEndVnode)) {
      patchVnode(
        oldEndVnode,
        newEndVnode,
        insertedVnodeQueue,
        newCh,
        newEndIdx
      );
      oldEndVnode = oldCh[--oldEndIdx];
      newEndVnode = newCh[--newEndIdx];
    } else if (sameVnode(oldStartVnode, newEndVnode)) {
      // Vnode moved right
      patchVnode(
        oldStartVnode,
        newEndVnode,
        insertedVnodeQueue,
        newCh,
        newEndIdx
      );
      canMove &amp;&amp;
        nodeOps.insertBefore(
          parentElm,
          oldStartVnode.elm,
          nodeOps.nextSibling(oldEndVnode.elm)
        );
      oldStartVnode = oldCh[++oldStartIdx];
      newEndVnode = newCh[--newEndIdx];
    } else if (sameVnode(oldEndVnode, newStartVnode)) {
      // Vnode moved left
      patchVnode(
        oldEndVnode,
        newStartVnode,
        insertedVnodeQueue,
        newCh,
        newStartIdx
      );
      canMove &amp;&amp;
        nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
      oldEndVnode = oldCh[--oldEndIdx];
      newStartVnode = newCh[++newStartIdx];
    } else {
      if (isUndef(oldKeyToIdx))
        oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);
      idxInOld = isDef(newStartVnode.key)
        ? oldKeyToIdx[newStartVnode.key]
        : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);
      if (isUndef(idxInOld)) {
        // New element
        createElm(
          newStartVnode,
          insertedVnodeQueue,
          parentElm,
          oldStartVnode.elm,
          false,
          newCh,
          newStartIdx
        );
      } else {
        // vnodeToMove将要移动的节点
        vnodeToMove = oldCh[idxInOld];
        if (sameVnode(vnodeToMove, newStartVnode)) {
          patchVnode(
            vnodeToMove,
            newStartVnode,
            insertedVnodeQueue,
            newCh,
            newStartIdx
          );
          oldCh[idxInOld] = undefined;
          canMove &amp;&amp;
            nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm);
        } else {
          // same key but different element. treat as new element
          createElm(
            newStartVnode,
            insertedVnodeQueue,
            parentElm,
            oldStartVnode.elm,
            false,
            newCh,
            newStartIdx
          );
        }
      }
      // vnodeToMove将要移动的节点
      newStartVnode = newCh[++newStartIdx];
    }
  }
  // 旧节点完成，新的没完成
  if (oldStartIdx &gt; oldEndIdx) {
    refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;
    addVnodes(
      parentElm,
      refElm,
      newCh,
      newStartIdx,
      newEndIdx,
      insertedVnodeQueue
    );
    // 新的完成，老的没完成
  } else if (newStartIdx &gt; newEndIdx) {
    removeVnodes(oldCh, oldStartIdx, oldEndIdx);
  }
}
</code></pre>
<h2 id="compile">Compile</h2>
<p>一个 vue 组件如下所属，是由 3 部分组成，template,script,style。而在刚学 vue 的时候，写起 template 就和我们直接写 html 一样，只需要记几个指令，就可以享受流畅的开发体验。刚学 vue 的我并不知道模版编译，v-dom 这些东西。 天真的以为就是纯 html 而已。</p>
<p>过了很久，我了解到并不是单纯的 html，对 spa 应用也有了更深入的了解。本文就来聊聊模版编译。</p>
<pre><code class="language-javascript">&lt;template&gt;
    &lt;div class=&quot;&quot;&gt;

    &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
export default {
   name:&quot;&quot;,
   props: {
   },
   components: {
   },
   data() {
      return {
      }
   },
   computed: {
   },
   watch: {
   },
   created() {
   },
   mounted() {
   }
}
&lt;/script&gt;

&lt;style lang=&quot;less&quot; scoped&gt;

&lt;/style&gt;
</code></pre>
<h3 id="渲染器">渲染器</h3>
<p>vue 中模版编译的核心是渲染器。渲染器的工作流程分为两个阶段：mount 和 patch，如果旧的 VNode 存在，则会使用新的 VNode 与旧的 VNode 进行对比，试图以最小的资源开销完成 DOM 的更新，这个过程就叫 patch，或“打补丁”。如果旧的 VNode 不存在，则直接将新的 VNode 挂载成全新的 DOM，这个过程叫做 mount。</p>
<p>渲染器会针对不同类型的模版元素进行分别处理，主要包括组件，hmtl 元素，web components 元素，svg 元素，纯文本元素等。如下所示会通过<code>flags</code>来标记不同的类型，然后通过类型来处理不同等元素。</p>
<pre><code class="language-js">function mount(vnode, container) {
  const { flags } = vnode;
  if (flags &amp; VNodeFlags.ELEMENT) {
    // 挂载普通标签
    mountElement(vnode, container);
  } else if (flags &amp; VNodeFlags.COMPONENT) {
    // 挂载组件
    mountComponent(vnode, container);
  } else if (flags &amp; VNodeFlags.TEXT) {
    // 挂载纯文本
    mountText(vnode, container);
  } else if (flags &amp; VNodeFlags.FRAGMENT) {
    // 挂载 Fragment
    mountFragment(vnode, container);
  } else if (flags &amp; VNodeFlags.PORTAL) {
    // 挂载 Portal
    mountPortal(vnode, container);
  }
}
</code></pre>
<h3 id="编译器">编译器</h3>
<p>vue 对整个模版的编译的工作很多，包括处理各种类型的组件，添加事件监听，处理模版语法，处理作用域，DOM 属性和 vue attrs</p>
<p>vue 中是通过<code>createCompilerCreator</code>来创建编译器对象，对模版进行编译。它本身是一个高阶函数 会在此返回一个函数。</p>
<ul>
<li>createCompiler 用以创建编译器，返回值是 compile 以及 compileToFunctions。</li>
<li>compile 是一个编译器，它会将传入的 template 转换成对应的 AST、render 函数以及 staticRenderFns 函数。</li>
<li>而 compileToFunctions 则是带缓存的编译器，同时 staticRenderFns 以及 render 函数会被转换成 Funtion 对象。</li>
<li>因为不同平台有一些不同的 options，所以 createCompiler 会根据平台区分传入一个 baseOptions，会与 compile 本身传入的 options 合并得到最终的 finalOptions。</li>
</ul>
<pre><code class="language-js">export function createCompilerCreator(baseCompile: Function): Function {
  return function createCompiler(baseOptions: CompilerOptions) {
    // compile函数
    function compile(
      template: string,
      options?: CompilerOptions
    ): CompiledResult {
      const finalOptions = Object.create(baseOptions);
      const errors = [];
      const tips = [];

      let warn = (msg, range, tip) =&gt; {
        (tip ? tips : errors).push(msg);
      };
      // 合并options
      if (options) {
        // 合并modules
        if (options.modules) {
          finalOptions.modules = (baseOptions.modules || []).concat(
            options.modules
          );
        }
        // 合并directives
        if (options.directives) {
          finalOptions.directives = extend(
            Object.create(baseOptions.directives || null),
            options.directives
          );
        }
        //拷贝一份option api
        for (const key in options) {
          if (key !== &quot;modules&quot; &amp;&amp; key !== &quot;directives&quot;) {
            finalOptions[key] = options[key];
          }
        }
      }
      const compiled = baseCompile(template.trim(), finalOptions);
      compiled.errors = errors;
      compiled.tips = tips;
      return compiled;
    }
    return {
      compile,
      // compileToFunctions是一个函数
      compileToFunctions: createCompileToFunctionFn(compile),
    };
  };
}
</code></pre>
<h3 id="编译流程">编译流程</h3>
<p>编译流程： baseCompile -&gt; parse -&gt; parseHTML -&gt; options.start -&gt; options.end -&gt; closeElement -&gt; processSlotContent</p>
<p>createCompilerCreator 函数处理完成后，就得到了优化的 js 代码</p>
<pre><code class="language-js">export const createCompiler = createCompilerCreator(function baseCompile(
  template: string,
  options: CompilerOptions
): CompiledResult {
  // 把模版编译成ast语法树
  const ast = parse(template.trim(), options);
  if (options.optimize !== false) {
    // 优化ast
    optimize(ast, options);
  }
  // 把ast变成字符串形式的js代码
  const code = generate(ast, options);
  return {
    ast,
    render: code.render,
    staticRenderFns: code.staticRenderFns,
  };
});
</code></pre>
<p>得到了转化后的代码，通过 createCompileToFunctionFn 进行下一步的操作，在进入 compileToFunctions 以后，会先检查缓存中是否有已经编译好的结果，如果有结果则直接从缓存中读取。 这样做防止每次同样的模板都要进行重复的编译工作。</p>
<pre><code class="language-js">export function createCompileToFunctionFn(compile: Function): Function {
  const cache = Object.create(null);

  return function compileToFunctions(
    template: string,
    options?: CompilerOptions,
    vm?: Component
  ): CompiledFunctionResult {
    options = extend({}, options);
    const warn = options.warn || baseWarn;
    delete options.warn;

    // check cache
    // 读取缓存，空间换时间
    const key = options.delimiters
      ? String(options.delimiters) + template
      : template;
    if (cache[key]) {
      return cache[key];
    }

    // 保存编译结果
    const compiled = compile(template, options);

    const res = {};
    const fnGenErrors = [];
    res.render = createFunction(compiled.render, fnGenErrors);
    res.staticRenderFns = compiled.staticRenderFns.map((code) =&gt; {
      return createFunction(code, fnGenErrors);
    });

    return (cache[key] = res);
  };
}
</code></pre>
<p>缓存完成模版编译的结果，通过 createFunction 返回 render 函数。该函数的作用就是直接把字符串 js 代码转为一个函数。</p>
<pre><code class="language-js">// 把字符串代码，通过new Function转为执行的函数
function createFunction(code, errors) {
  try {
    return new Function(code);
  } catch (err) {
    errors.push({ err, code });
    return noop;
  }
}
</code></pre>
<p>然后就得到了可行性的 render 函数 compileToFunctions。在入口处会调用该函数对 template 进行编译（源码已精简）</p>
<pre><code class="language-js">Vue.prototype.$mount = function (
  el?: string | Element,
  hydrating?: boolean
): Component {
  // 如果存在el，就取到当前到DOM，可以是css选择器，也可以是DOM节点
  el = el &amp;&amp; query(el)
  // el不能是body或者html元素
  if (el === document.body || el === document.documentElement) {
    process.env.NODE_ENV !== 'production' &amp;&amp; warn(
      `Do not mount Vue to &lt;html&gt; or &lt;body&gt; - mount to normal elements instead.`
    )
    return this
  }

  const options = this.$options
  /**
   *  解析模板 转为render
   *  如果不存在render就是用template模版的内容
   */
  if (!options.render) {
    let template = options.template
    if (template) {
      if (typeof template === 'string') {
        if (template.charAt(0) === '#') {
          template = idToTemplate(template)
        }
      } else if (template.nodeType) {
        template = template.innerHTML
      } else {
        if (process.env.NODE_ENV !== 'production') {
          warn('invalid template option:' + template, this)
        }
        return this
      }
    } else if (el) {
      template = getOuterHTML(el)
    }
    if (template) {
      /* istanbul ignore if */
      if (process.env.NODE_ENV !== 'production' &amp;&amp; config.performance &amp;&amp; mark) {
        mark('compile')
      }
      // 在这边编译模版，产生render函数
      const { render, staticRenderFns } = compileToFunctions(template, {
        outputSourceRange: process.env.NODE_ENV !== 'production',
        shouldDecodeNewlines,
        shouldDecodeNewlinesForHref,
        delimiters: options.delimiters,
        comments: options.comments
      }, this)
      options.render = render
      options.staticRenderFns = staticRenderFns
    }
  }
  // 渲染DOM
  return mount.call(this, el, hydrating)
}
</code></pre>
        </div>
        
        <div class="my-4">
    
    <a href="/tags/%E5%89%8D%E7%AB%AF/" class="inline-block bg-tertiary-bg text-sm rounded px-3 py-1 my-1 mr-2 hover:text-eureka">#前端</a>
    
    <a href="/tags/vue%E5%8E%9F%E7%90%86/" class="inline-block bg-tertiary-bg text-sm rounded px-3 py-1 my-1 mr-2 hover:text-eureka">#vue原理</a>
    
    <a href="/tags/vue%E6%BA%90%E7%A0%81/" class="inline-block bg-tertiary-bg text-sm rounded px-3 py-1 my-1 mr-2 hover:text-eureka">#vue源码</a>
    
</div>
        
        
        
        
        
        
        
<div class="flex flex-col md:flex-row md:justify-between -mx-2 mt-4 px-2 pt-4 border-t">
    <div>
        
    </div>
    <div class="md:text-right mt-4 md:mt-0">
        
        <span class="block font-bold">下一篇</span>
        <a href="/posts/2021/vue_principle_04/" class="block">vue.js(2.x)原理 - Vue内置指令及内置组件（v-show, v-if, v-for , v-model,keep-alive)「04」</a>
        
    </div>
</div>

        
    </div>
    
    <div class="col-span-2">
        
        
        <div class="sticky top-16 z-10 hidden lg:block px-6 py-4  bg-primary-bg ">
    <span class="text-lg font-semibold">本页内容</span>
</div>
<div class="sticky-toc hidden lg:block px-6 pb-6 ">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#v-dom">v-dom</a>
      <ul>
        <li><a href="#是什么">是什么</a></li>
        <li><a href="#改进部分">改进部分</a>
          <ul>
            <li><a href="#key-的变化">key 的变化</a></li>
            <li><a href="#patchvnode">patchVnode</a></li>
            <li><a href="#核心-diff">核心 diff</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#compile">Compile</a>
      <ul>
        <li><a href="#渲染器">渲染器</a></li>
        <li><a href="#编译器">编译器</a></li>
        <li><a href="#编译流程">编译流程</a></li>
      </ul>
    </li>
  </ul>
</nav>
</div>
<script>
    window.addEventListener('DOMContentLoaded', () => {
        enableStickyToc();
    });
</script>
        
    </div>
    

    
    
    <div
        class="col-span-2  lg:col-span-6 bg-secondary-bg rounded p-6">
        <h2 class="text-lg font-semibold mb-4">相关</h2>
        <div class="content">
            
            <a href="/posts/2021/vue_principle_04/">vue.js(2.x)原理 - Vue内置指令及内置组件（v-show, v-if, v-for , v-model,keep-alive)「04」</a>
            <br />
            
            <a href="/posts/2021/vue_principle_03/">vue.js(2.x)原理 - Vue响应式核心Observer,Dep及Watcher和异步更新队列「03」</a>
            <br />
            
            <a href="/posts/2021/vue_principle_02/">vue.js(2.x)原理 - new Vue流程梳理 及源码版生命周期分析「02」</a>
            <br />
            
            <a href="/posts/2021/vue_principle_01/">【原理探索】vue.js(2.x)框架底层原理- 实现mini vue「01」</a>
            <br />
            
            <a href="/posts/2021/vue_principle_main/">【原理探索】vue.js超级全家桶--原理分析及技术学习清单</a>
            <br />
            
            <a href="/posts/2021/snabbdom_source/">【技术分享】virtual DOM的思考及snabbdom库源码解读</a>
            <br />
            
        </div>
    </div>
    
</div>
<script>
    document.addEventListener('DOMContentLoaded', ()=>{
        hljs.initHighlightingOnLoad();
    })
</script>

      </div>
    </div>
    
  </main>
  <footer class="pl-scrollbar">
    <div class="w-full max-w-screen-xl mx-auto"><div class="text-center p-6 pin-b">
    <p class="text-sm text-tertiary-text">&copy; 2019-2021   gzg1023 &middot;  Powered by the <a href="https://github.com/wangchucheng/hugo-eureka" class="hover:text-eureka">Eureka</a> theme for <a href="https://gohugo.io" class="hover:text-eureka">Hugo</a></p>
</div></div>
  </footer>
</body>

</html>